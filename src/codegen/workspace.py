"""Workspace management for code generation."""

import shutil
import subprocess
from pathlib import Path
from typing import Optional, Dict, TYPE_CHECKING

if TYPE_CHECKING:
    from ..orchestrator.disturbances import DisturbanceEngine
    from ..tools.kanban import KanbanBoard
    from ..tools.shared_context import SharedContextDB


class WorkspaceManager:
    """Manages workspaces for agent code generation.

    Each sprint gets its own workspace directory with git initialized.
    Supports cloning from remote repos or starting fresh.
    """

    def __init__(
        self,
        base_dir: str,
        repo_config: Optional[Dict] = None,
        workspace_mode: str = "per_story",
        disturbance_engine: Optional["DisturbanceEngine"] = None,
        kanban: Optional["KanbanBoard"] = None,
        db: Optional["SharedContextDB"] = None,
    ):
        """Initialize workspace manager.

        Args:
            base_dir: Base directory for all workspaces (e.g., /tmp/agent-workspace)
            repo_config: Optional config for cloning existing repos
                {
                    "url": "https://github.com/org/project.git",
                    "branch": "main",
                    "clone_mode": "fresh" | "incremental"
                }
            workspace_mode: "per_story" (isolated per story) or "per_sprint" (shared within sprint)
            disturbance_engine: Optional disturbance engine for merge conflict detection
            kanban: Optional kanban board for disturbance tracking
            db: Optional database for disturbance tracking
        """
        self.base_dir = Path(base_dir)
        self.repo_config = repo_config or {}
        self.workspace_mode = workspace_mode
        self.disturbance_engine = disturbance_engine
        self.kanban = kanban
        self.db = db
        self.base_dir.mkdir(parents=True, exist_ok=True)

    def create_sprint_workspace(
        self, sprint_num: int, story_id: Optional[str] = None
    ) -> Path:
        """Create a workspace for a sprint with feature branch.

        Follows stable main + gitflow:
        1. Initialize/clone repo (or reuse if incremental mode)
        2. Create feature branch for story: feature/<story-id>

        Args:
            sprint_num: Sprint number
            story_id: Optional story ID for sub-workspace

        Returns:
            Path to the workspace directory
        """
        # Determine workspace path based on mode
        if self.workspace_mode == "per_story" and story_id:
            # Isolated workspace per story
            workspace = self.base_dir / f"sprint-{sprint_num}" / story_id
        else:
            # Shared workspace for entire sprint
            workspace = self.base_dir / f"sprint-{sprint_num}"

        clone_mode = self.repo_config.get("clone_mode", "fresh")
        workspace_exists = workspace.exists()

        # Handle workspace creation based on mode
        if workspace_exists and clone_mode == "incremental":
            # Incremental mode: reuse existing workspace, pull latest changes
            if self.repo_config.get("url"):
                self._pull_latest(workspace)
            # If fresh repo (no remote), just reuse as-is
        elif workspace_exists and self.workspace_mode == "per_sprint":
            # Shared sprint workspace already exists, just switch to main before creating new branch
            if self.repo_config.get("url") or (workspace / ".git").exists():
                branch = self.repo_config.get("branch", "main")
                subprocess.run(
                    ["git", "checkout", branch],
                    cwd=workspace,
                    capture_output=True,
                    check=False,
                )
        else:
            # Fresh mode or new workspace: delete and recreate
            if workspace_exists:
                shutil.rmtree(workspace)

            workspace.mkdir(parents=True, exist_ok=True)

            # Initialize or clone
            if self.repo_config.get("url"):
                self._clone_repo(workspace)
            else:
                self._init_fresh_repo(workspace)

        # Create feature branch if story_id provided
        if story_id:
            self.create_feature_branch(workspace, story_id)

        return workspace

    def _init_fresh_repo(self, workspace: Path) -> None:
        """Initialize a fresh git repo in the workspace."""
        subprocess.run(["git", "init"], cwd=workspace, capture_output=True, check=True)

        subprocess.run(
            ["git", "config", "user.name", "Agile Agent Team"],
            cwd=workspace,
            capture_output=True,
            check=True,
        )

        subprocess.run(
            ["git", "config", "user.email", "agents@example.com"],
            cwd=workspace,
            capture_output=True,
            check=True,
        )

        # Create initial commit
        readme = workspace / "README.md"
        readme.write_text("# Project\n\nGenerated by Agile Agent Team\n")

        subprocess.run(
            ["git", "add", "README.md"], cwd=workspace, capture_output=True, check=True
        )
        subprocess.run(
            ["git", "commit", "-m", "Initial commit"],
            cwd=workspace,
            capture_output=True,
            check=True,
        )

    def _clone_repo(self, workspace: Path) -> None:
        """Clone a repo into the workspace."""
        url = self.repo_config["url"]
        branch = self.repo_config.get("branch", "main")

        subprocess.run(
            ["git", "clone", "--branch", branch, "--depth", "1", url, str(workspace)],
            capture_output=True,
            check=True,
        )

    def _pull_latest(self, workspace: Path) -> None:
        """Pull latest changes from remote in incremental mode."""
        branch = self.repo_config.get("branch", "main")

        # Checkout main/base branch
        subprocess.run(
            ["git", "checkout", branch],
            cwd=workspace,
            capture_output=True,
            check=False,  # May fail if already on branch
        )

        # Pull latest changes with merge conflict detection
        try:
            _ = subprocess.run(
                ["git", "pull", "origin", branch],
                cwd=workspace,
                capture_output=True,
                check=True,
                text=True,
            )
        except subprocess.CalledProcessError as e:
            # Check if it's a merge conflict
            error_output = e.stderr + e.stdout
            if "CONFLICT" in error_output or "Automatic merge failed" in error_output:
                # Detect merge conflict disturbance
                if self.disturbance_engine and self.kanban and self.db:
                    import asyncio

                    asyncio.create_task(
                        self.disturbance_engine.detect_merge_conflict(
                            card_id="workspace_init",
                            git_error=error_output,
                            kanban=self.kanban,
                            db=self.db,
                        )
                    )
            # Re-raise the error
            raise

    def create_feature_branch(self, workspace: Path, story_id: str) -> str:
        """Create a feature branch for a story.

        Args:
            workspace: Workspace directory
            story_id: Story ID (e.g., "US-001")

        Returns:
            Branch name created
        """
        branch_name = f"feature/{story_id.lower()}"

        subprocess.run(
            ["git", "checkout", "-b", branch_name],
            cwd=workspace,
            capture_output=True,
            check=True,
        )

        return branch_name

    def get_workspace_for_sprint(self, sprint_num: int) -> Optional[Path]:
        """Get existing workspace for a sprint if it exists."""
        workspace = self.base_dir / f"sprint-{sprint_num}"
        return workspace if workspace.exists() else None

    def merge_to_main(self, workspace: Path, branch_name: str):
        """Merge a feature branch to main.

        Args:
            workspace: Workspace directory
            branch_name: Branch to merge (e.g., "feature/us-001")
        """
        base_branch = self.repo_config.get("branch", "main")

        # Checkout main
        subprocess.run(
            ["git", "checkout", base_branch],
            cwd=workspace,
            capture_output=True,
            check=True,
        )

        # Merge feature branch
        subprocess.run(
            [
                "git",
                "merge",
                "--no-ff",
                branch_name,
                "-m",
                f"Merge {branch_name} into {base_branch}",
            ],
            cwd=workspace,
            capture_output=True,
            check=True,
        )

        # Optionally delete feature branch
        subprocess.run(
            ["git", "branch", "-d", branch_name],
            cwd=workspace,
            capture_output=True,
            check=False,  # Don't fail if branch deletion fails
        )

    def copy_workspace_to_next_sprint(self, from_sprint: int, to_sprint: int) -> Path:
        """Copy previous sprint's workspace to continue work in next sprint.

        Enables incremental development across sprints.

        Args:
            from_sprint: Source sprint number
            to_sprint: Destination sprint number

        Returns:
            Path to the new sprint workspace
        """
        source = self.base_dir / f"sprint-{from_sprint}"
        dest = self.base_dir / f"sprint-{to_sprint}"

        if not source.exists():
            raise ValueError(
                f"Source workspace for sprint {from_sprint} does not exist"
            )

        if dest.exists():
            shutil.rmtree(dest)

        # Copy entire workspace
        shutil.copytree(source, dest)

        # Checkout main branch in new workspace
        base_branch = self.repo_config.get("branch", "main")
        subprocess.run(
            ["git", "checkout", base_branch], cwd=dest, capture_output=True, check=False
        )

        return dest

    def cleanup_old_workspaces(self, keep_last_n: int = 3) -> None:
        """Clean up old sprint workspaces, keeping only the last N."""
        sprint_dirs = sorted(
            [d for d in self.base_dir.glob("sprint-*") if d.is_dir()],
            key=lambda p: int(p.name.split("-")[1]),
            reverse=True,
        )

        for old_dir in sprint_dirs[keep_last_n:]:
            shutil.rmtree(old_dir)
